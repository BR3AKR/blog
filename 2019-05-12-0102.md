<!--META--
author: Sean K Smith
created: 2019-05-12T13:02:32Z
edited: 2019-05-12T13:02:32Z
title: Reinvent the Wheel (Sometimes)
subtitle: becoming a better programmer by doing what's already done
tags:
  - learning
--END-->
I remember being taught in school to avoid "reinventing the wheel". While in a professional development I agree with that - I think that on your own time, on your own projects, you should strongly consider working from scratch.

In the workplace, you're often working against the clock. You want to deliver as much value as possible in as little time as possible. There is very little appetite for "taking your time", and sometimes even "doing things right" can get shoved aside for especially urgent needs (though you really should push for doing things right the first time). A big part of getting things done quickly is to heavily use existing libraries, and to short cut finding solutions (looking up the "answer" on Stack Overflow). While this is fine and totally understandable in a situation where you need to get the job done quickly, it is not always the best way to learn.

There are libraries for nearly every basic problem you are trying to solve. String formatting, request routing, sorting, templating, and source code generation are all problems that have been solved hundreds of times. These problems were solved by talented developers standing on the shoulders of other talented developers. Their solutions are robust and efficient. They are peer reviewed and battle hardened in intense production environments. Why in the world would you even bother *considering* to write code competing with that? Why reinvent the wheel?

The first, and most important reason you might consider reinventing the wheel is to *learn*. A lot of libraries exist because they have plucked low-hanging fruit from the tree of problems. If you never have the opportunity to solve those problems yourself, you are denied the learning opportunity that comes with writing that code. The second reason is that you can write something simpler that fits your problem better. Libraries are often one-size-fits-all monstrosities with thousands of nice-to-have features that you will literally never even consider touching. They do that, because they want their library to be useful for all sorts of use cases. That's perfectly reasonable, but you don't need all of that. You really have just a few specific use cases - you can build the tools that only *you* need solved.

In your own projects, when you no longer have these constraints I urge you to *slow down*. Instead of immediately reaching for that framework you're so comfortable with, consider writing an extremely pared down version of it. Chances are you may only really need a few features from it in the first place. When you're stuck, instead of immediately searching the web for your exact problem and reading the first stack trace answer - take a moment to have a look at the actual documentation. Try to get yourself a more wholistic understanding of the space you are having your problem in.

I wouldn't say that this is feasible all of the time. Sometimes even though what you're working on is a passion project and no one is pressuring you to get it done faster - you're still excited to get it done. That's ok! Better to get a project done that you're excited about than let it linger because you dread writing the whole thing from scratch yourself. But maybe instead of grabbing a library for a few helper functions, write those functions yourself. Once you are done, you could compare it to what they've written (assuming it's open source). What did they do differently? Are they handlig some weird edge cases you hadn't considered? Can your function get away with being more simple because it doesn't have a whole library to consider?

When I was considering starting this blog, I spoke with a friend of mine about it. He recommended I consider using a stack of software that would let me keep my blog posts as markdown in github. I thought the idea was really cool and got to work putting the thing together. During that process it occurred to me that I was perfectly capable of building some of the bits and pieces myself. So I tried it my own way and was rewarded with all sorts of fun and interesting problems. I ended up with a pet project that I could keep coming back to and adding little bits and features to. I could smooth out parts of the process and slowly end up with something that was a joy to work on. I'm saving the details for how this blog is structured for a future post but what I really want to illustrate here is that while I spent a few days writing code myself, I learned so much along the way - and that felt great.